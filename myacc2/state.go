package myacc2

import (
	"sort"
)

const STATEINC = 200
const EPSLINC = 8 // increment of epsilons
const TRANSIZE = 16000
const ACTSIZE = 240000
const ACCEPTCODE = 8191
const ERRCODE = 8190

// no, left, right, binary assoc.
const (
	NOASC = iota
	LASC
	RASC
	BASC
)

var nstate = 0
var stateChain = make([]int, NSTATES) // chain states of the same transition symbol together. idx is the state, value is previous state of the same transition symbol
var tstates []int                     // latest state generated by a terminal transition symbol
var ntstates []int                    // latest state generated by a non-terminal transition symbol
var termN = 0                         // idx of terminal symbol in terms. starting from 1
var nontermN = -1                     // idx of non-terminal symbol in non-terms, including $accept. must add 1 to get total number of nonterms!
var trans []int                       // temporarily store transitions for each symbol after closing a state
var maxRed int                        // default reduction of a state
var defReds []int                     // default reductions of states
var aptPrd []int                      // compact info: associativity, precedence, type of prds
var aptTerm []int                     // compact info: associativity, precedence, type of terminal symbols

var epsilons = map[int][]item{}

func addKernItem(itemI item) {
	itemI.off++
	itemI.first = itemI.prd[itemI.off]

	i := kernlp[nstate+1]
	if i >= len(kernls) {
		extend(&kernls, STATEINC)
	}
	kernls[i] = itemI.clone()
	kernlp[nstate+1] = i + 1
}

// stategen generates the LALR(1) kernel items of states
func stategen() {
	nstate = 0
	tstates = make([]int, termN)     // include $end(0)
	ntstates = make([]int, nontermN) // include $accept(NTBASE)
	trans = make([]int, nontermN)
	clkset = newLkset()
	addKernItem(item{0, prods[0], 0, newLkset()})
	nstate++
	for i := 0; i < nstate; i++ {
		closure(i)
		for j := 0; j < cwp; j++ {
			w := wSet[j]
			if w.done {
				continue
			}
			w.done = true
			first := w.item.first
			// ============ 0 is for prd 0!, $end should be from 1
			// ============= should we skip 0???
			if first == 0 || first == NTBASE { // skip $end and $accept
				continue
			}
			if first < 0 { // end of prd after derived
				if j >= kernlp[i+1]-kernlp[i] { // not kernel item of current state
					// hasEpsilons[i] = true // ========= in output: do closure if has epsilon, closure0 if no epsilon
					epsilons[i] = append(epsilons[i], w.item.clone())
				}
				continue
			}
			kernlp[nstate+1] = kernlp[nstate] // next state hold 0 items initially
			addKernItem(w.item)
			for k := j + 1; k < cwp; k++ {
				if first == wSet[k].item.first {
					addKernItem(wSet[k].item)
					wSet[k].done = true
				}
			}
			s := newState(first)
			if first > NTBASE { // terminal symbol
				trans[first-NTBASE] = s
			}
		}
		gotoIdx[i] = packGotosRow() - 1 // $accept is excluded from goTos
	}
}

// newState creates a new state for a transtion symbol or merge it with existing state
func newState(sym int) int {
	p1, p2 := kernlp[nstate], kernlp[nstate+1]
	if p1 == p2 { // no items for new state. skip. (just safeguard)
		return 0
	}
	// sort to help search later
	sort.Slice(kernls[p1:p2], func(i, j int) bool {
		return id(kernls[i].prd) < id(kernls[j].prd) ||
			(id(kernls[i].prd) == id(kernls[j].prd) && kernls[i].off < kernls[j].off)
	})

	if prev := searchState(nstate, sym); prev > 0 { // found previous state, merge
		q1, q2 := kernlp[prev], kernlp[prev+1]
		kernlp[nstate+1] = kernlp[nstate] // delete current items
		for k, l := p1, q1; l < q2; k, l = k+1, l+1 {
			kernls[l].lkset.union(kernls[k].lkset)
		}
		return prev
	}
	// not found, completely new state!
	if sym >= NTBASE {
		stateChain[nstate] = ntstates[sym-NTBASE]
		ntstates[sym-NTBASE] = nstate
	} else {
		stateChain[nstate] = tstates[sym]
		tstates[sym] = nstate
	}
	nstate++
	return nstate - 1
}

// retrieve existing state for current items
func retrieveState(sym int) int {
	p1, p2 := kernlp[nstate], kernlp[nstate+1]

	defer func() {
		kernlp[nstate+1] = kernlp[nstate] // delete added items
	}()

	if p1 == p2 { // no items for new state. skip. (just safeguard)
		return 0
	}
	// sort to help search later
	sort.Slice(kernls[p1:p2], func(i, j int) bool {
		return id(kernls[i].prd) < id(kernls[j].prd) ||
			(id(kernls[i].prd) == id(kernls[j].prd) && kernls[i].off < kernls[j].off)
	})

	if prev := searchState(nstate, sym); prev > 0 { // found previous state, merge
		return prev
	}
	return 0
}

// searchState looks for the identical previous state of the same transition symbol (without considering the lookahead set)
func searchState(n int, sym int) int {
	p1, p2 := kernlp[n], kernlp[n+1]
	var prev int
	if sym >= NTBASE {
		prev = ntstates[sym-NTBASE]
	} else {
		prev = tstates[sym]
	}
prevState:
	for ; prev != 0; prev = stateChain[prev] {
		q1, q2 := kernlp[prev], kernlp[prev+1]
		if (p2 - p1) != (q2 - q1) { // kernels are not the same size
			continue
		}
		for k, l := p1, q1; l < q2; k, l = k+1, l+1 {
			if id(kernls[k].prd) != id(kernls[l].prd) || kernls[k].off != kernls[l].off {
				continue prevState
			}
		}
		return prev
	}

	return -1
}
