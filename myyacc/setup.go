package myyacc

import (
	"bufio"
	"flag"
	"fmt"
	"go/format"
	"os"
	"strings"
)

var foutput *bufio.Writer // y.output file
var stderr *bufio.Writer
var initialstacksize = 16
var start int
var prdptr [][]int // pointers to descriptions of productions
var nprod = 1      // number of productions
var levprd []int   // precedence levels for the productions
var rlines []int   // line number for this rule

func open(s string) *bufio.Reader {
	fi, err := os.Open(s)
	if err != nil {
		errorf("error opening %v: %v", s, err)
	}
	//fmt.Printf("open %v\n", s);
	return bufio.NewReader(fi)
}

func create(s string) *bufio.Writer {
	fo, err := os.Create(s)
	if err != nil {
		errorf("error creating %v: %v", s, err)
	}
	//fmt.Printf("create %v mode %v\n", s);
	return bufio.NewWriter(fo)
}

func openup() {
	infile = flag.Arg(0)
	finput = open(infile)
	if finput == nil {
		errorf("cannot open %v", infile)
	}

	foutput = nil
	if vflag != "" {
		foutput = create(vflag)
		if foutput == nil {
			errorf("can't create file %v", vflag)
		}
	}

	ftable = nil
	if oflag == "" {
		oflag = "y.go"
	}
	ftable = create(oflag)
	if ftable == nil {
		errorf("can't create file %v", oflag)
	}

}

// allocate enough room to hold another production
func moreprod() {
	if nprod >= len(prdptr) {
		extend(&prdptr, PRODINC)
		extend(&levprd, PRODINC)
		extend(&rlines, PRODINC)
	}
}

func setup() {
	var j, ty int

	stderr = bufio.NewWriter(os.Stderr)
	foutput = nil

	flag.Parse()
	if flag.NArg() != 1 {
		usage()
	}
	if initialstacksize < 1 {
		// never set so cannot happen
		fmt.Fprintf(stderr, "yacc: stack size too small\n")
		usage()
	}
	yaccpar = strings.Replace(template, "$$", prefix, -1)
	openup()

	fmt.Fprintf(ftable, "// Code generated by goyacc %s. DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))

	addInitSyms()
	i := 0

	t := gettok()

outer:
	for {
		switch t {
		default:
			errorf("syntax error tok=%v", t-PRIVATE)

		case MARK, ENDFILE:
			break outer

		case ';':
			// Do nothing.

		case START:
			t = gettok()
			if t != IDENTIFIER {
				errorf("bad %%start construction")
			}
			start = chfind(1, tokname)

		case ERROR:
			lno := lineno
			var tokens []string
			for {
				t := gettok()
				if t == ':' {
					break
				}
				if t != IDENTIFIER && t != IDENTCOLON {
					errorf("bad syntax in %%error")
				}
				tokens = append(tokens, tokname)
				if t == IDENTCOLON { // ========= different of IDENTCOLON AND ;?
					break
				}
			}
			if gettok() != IDENTIFIER {
				errorf("bad syntax in %%error")
			}
			errors = append(errors, Error{lno, tokens, tokname})

		case TYPEDEF:
			t = gettok()
			if t != TYPENAME {
				errorf("bad syntax in %%type")
			}
			ty = numbval
			for {
				t = gettok()
				switch t {
				case IDENTIFIER:
					t = chfind(1, tokname)
					if t < NTBASE {
						j = TYPE(preds[t])
						if j != 0 && j != ty {
							errorf("type redeclaration of token %s",
								terms[t].name)
						} else {
							preds[t] = SETTYPE(preds[t], ty)
						}
					} else {
						j = nonterms[t-NTBASE].value
						if j != 0 && j != ty {
							errorf("type redeclaration of nonterminal %v",
								nonterms[t-NTBASE].name)
						} else {
							nonterms[t-NTBASE].value = ty
						}
					}
					continue

				case ',':
					continue
				}
				break
			}
			continue

		case UNION:
			cpyunion()

		case LEFT, BINARY, RIGHT, TERM:
			// nonzero means new prec. and assoc.
			lev := t - TERM
			if lev != 0 {
				i++
			}
			ty = 0

			// get identifiers so defined
			t = gettok()

			// there is a type defined
			if t == TYPENAME {
				ty = numbval
				t = gettok()
			}
			for {
				switch t {
				case ',':
					t = gettok()
					continue

				case ';':
					// Do nothing.

				case IDENTIFIER:
					j = chfind(0, tokname)
					if j >= NTBASE {
						errorf("%v defined earlier as nonterminal", tokname)
					}
					if lev != 0 {
						if ASSOC(preds[j]) != 0 {
							errorf("redeclaration of precedence of %v", tokname)
						}
						preds[j] = SETASC(preds[j], lev)
						preds[j] = SETPLEV(preds[j], i)
					}
					if ty != 0 {
						if TYPE(preds[j]) != 0 {
							errorf("redeclaration of type of %v", tokname)
						}
						preds[j] = SETTYPE(preds[j], ty)
					}
					t = gettok()
					if t == NUMBER {
						terms[j].value = numbval
						t = gettok()
					}

					continue
				}
				break
			}
			continue

		case LCURLY:
			cpycode()
		}
		t = gettok()
	}

	if t == ENDFILE {
		errorf("unexpected EOF before %%")
	}

	fmt.Fprintf(fcode, "switch %snt {\n", prefix)

	moreprod()
	prdptr[0] = []int{NTBASE, start, 1, 0}

	nprod = 1
	curprod := make([]int, RULEINC)
	t = gettok()
	if t != IDENTCOLON {
		errorf("bad syntax on first rule")
	}

	if start == 0 {
		prdptr[0][1] = chfind(1, tokname)
	}

	// read rules
	// put into prdptr array in the format
	// target
	// followed by id's of terminals and non-terminals
	// followed by -nprod

	for t != MARK && t != ENDFILE {
		mem := 0

		// process a rule
		rlines[nprod] = lineno
		ruleline := lineno
		if t == '|' {
			curprod[mem] = prdptr[nprod-1][0]
			mem++
		} else if t == IDENTCOLON {
			curprod[mem] = chfind(1, tokname)
			if curprod[mem] < NTBASE {
				lerrorf(ruleline, "token illegal on LHS of grammar rule")
			}
			mem++
		} else {
			lerrorf(ruleline, "illegal rule: missing semicolon or | ?")
		}

		// read rule body
		t = gettok()
		for {
			for t == IDENTIFIER {
				curprod[mem] = chfind(1, tokname)
				if curprod[mem] < NTBASE {
					levprd[nprod] = preds[curprod[mem]]
				}
				mem++
				if mem >= len(curprod) {
					ncurprod := make([]int, mem+RULEINC)
					copy(ncurprod, curprod)
					curprod = ncurprod
				}
				t = gettok()
			}
			if t == PREC {
				if gettok() != IDENTIFIER {
					lerrorf(ruleline, "illegal %%prec syntax")
				}
				j = chfind(2, tokname)
				if j >= NTBASE {
					lerrorf(ruleline, "nonterminal "+nonterms[j-NTBASE].name+" illegal after %%prec")
				}
				levprd[nprod] = preds[j]
				t = gettok()
			}
			if t != '=' {
				break
			}
			levprd[nprod] |= ACTFLAG
			fmt.Fprintf(fcode, "\n\tcase %v:", nprod)
			fmt.Fprintf(fcode, "\n\t\t%sDollar = %sS[%spt-%v:%spt+1]", prefix, prefix, prefix, mem-1, prefix)
			cpyact(curprod, mem)

			// action within rule...
			t = gettok()
			if t == IDENTIFIER {
				// make it a nonterminal
				j = chfind(1, fmt.Sprintf("$$%v", nprod))

				//
				// the current rule will become rule number nprod+1
				// enter null production for action
				//
				prdptr[nprod] = make([]int, 2)
				prdptr[nprod][0] = j
				prdptr[nprod][1] = -nprod

				// update the production information
				nprod++
				moreprod()
				levprd[nprod] = levprd[nprod-1] & ^ACTFLAG
				levprd[nprod-1] = ACTFLAG
				rlines[nprod] = lineno

				// make the action appear in the original rule
				curprod[mem] = j
				mem++
				if mem >= len(curprod) {
					ncurprod := make([]int, mem+RULEINC)
					copy(ncurprod, curprod)
					curprod = ncurprod
				}
			}
		}

		for t == ';' {
			t = gettok()
		}
		curprod[mem] = -nprod
		mem++

		// check that default action is reasonable
		if ntypes != 0 && (levprd[nprod]&ACTFLAG) == 0 &&
			nonterms[curprod[0]-NTBASE].value != 0 {
			// no explicit action, LHS has value
			tempty := curprod[1]
			if tempty < 0 {
				lerrorf(ruleline, "must return a value, since LHS has a type")
			}
			if tempty >= NTBASE {
				tempty = nonterms[tempty-NTBASE].value
			} else {
				tempty = TYPE(preds[tempty])
			}
			if tempty != nonterms[curprod[0]-NTBASE].value {
				lerrorf(ruleline, "default action causes potential type clash")
			}
		}
		moreprod()
		prdptr[nprod] = make([]int, mem)
		copy(prdptr[nprod], curprod)
		nprod++
		moreprod()
		levprd[nprod] = 0
	}

	if TEMPSIZE < nterm+nnonterm+1 {
		errorf("too many tokens (%d) or non-terminals (%d)", nterm, nnonterm)
	}

	//
	// end of all rules
	// dump out the prefix code
	//

	fmt.Fprintf(fcode, "\n\t}")

	// put out non-literal terminals
	for i := TOKSTART; i <= nterm; i++ {
		// non-literals
		if terms[i].isconst {
			fmt.Fprintf(ftable, "const %v = %v\n", terms[i].name, terms[i].value)
		}
	}

	// put out names of tokens
	ftable.WriteRune('\n')
	fmt.Fprintf(ftable, "var %sToknames = [...]string{\n", prefix)
	for i := 1; i <= nterm; i++ {
		fmt.Fprintf(ftable, "\t%q,\n", terms[i].name)
	}
	fmt.Fprintf(ftable, "}\n")

	// put out names of states.
	// commented out to avoid a huge table just for debugging.
	// re-enable to have the names in the binary.
	ftable.WriteRune('\n')
	fmt.Fprintf(ftable, "var %sStatenames = [...]string{\n", prefix)
	//	for i:=TOKSTART; i<=ntokens; i++ {
	//		fmt.Fprintf(ftable, "\t%q,\n", tokset[i].name);
	//	}
	fmt.Fprintf(ftable, "}\n")

	ftable.WriteRune('\n')
	fmt.Fprintf(ftable, "const %sEofCode = 1\n", prefix)
	fmt.Fprintf(ftable, "const %sErrCode = 2\n", prefix)
	fmt.Fprintf(ftable, "const %sInitialStackSize = %v\n", prefix, initialstacksize)

	//
	// copy any postfix code
	//
	if t == MARK {
		if !lflag {
			fmt.Fprintf(ftable, "\n//line %v:%v\n", infile, lineno)
		}
		for {
			c := getrune(finput)
			if c == EOF {
				break
			}
			ftable.WriteRune(c)
		}
	}
}

func exit(status int) {
	if ftable != nil {
		ftable.Flush()
		ftable = nil
		gofmt()
	}
	if foutput != nil {
		foutput.Flush()
		foutput = nil
	}
	if stderr != nil {
		stderr.Flush()
		stderr = nil
	}
	os.Exit(status)
}

func gofmt() {
	src, err := os.ReadFile(oflag)
	if err != nil {
		return
	}
	src, err = format.Source(src)
	if err != nil {
		return
	}
	os.WriteFile(oflag, src, 0666)
}
